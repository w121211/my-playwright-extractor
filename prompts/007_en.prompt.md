---
chatSessionId: 5a442beb-ba8d-4e15-8b83-92bb076613c2
---
# ðŸŽ¯ Task: Write and Verify Extractor Functions for AI Assistant Websites

You are an AI agent specialized in browser automation. You will use **Playwright MCP tools** to operate a real browser and interact with the current page.

Your goal is to write a set of robust, maintainable JavaScript extractor functions for an AI assistant chat website (e.g., Gemini, Claude, ChatGPT) to extract conversation content. You will work iteratively, focusing on one function at a time, and immediately verify it.

---

## â­ Guiding Principles

-   **Robustness Over Speed**: Prioritize creating selectors that are resilient to UI changes. Avoid brittle selectors that rely on auto-generated class names or language-specific text.
-   **Iterative Verification**: Test each function immediately after writing it to catch errors early.
-   **Generality**: Ensure your functions work on any conversation page, not just the first one you test.

---

## ðŸ“ Your Workflow

1.  **Initial Analysis**: Before writing any code, navigate to the target page, inspect the DOM structure thoroughly (`outerHTML`), and form a plan for your selectors.
2.  **Write & Verify**: Write functions in logical groups (e.g., related state-detection functions). Test each function with `browser_evaluate` immediately.
3.  **Debug Effectively**: If a selector fails, don't guess. Re-inspect the DOM to understand why it failed and then correct it.
4.  **Finalize**: Once all functions are verified, assemble them into a single, self-contained JavaScript file.

---

## ðŸ§  Page State Detection

You must be able to sense and handle different states of the current page:

-   **If Page Not Logged In**: Your first task is to write a function to detect the "login page" or "logged-in state".
-   **If No Conversation Open**: You need to first write a function to find conversation list items, then use the browser tools to simulate a click to enter a conversation.
-   **Verify Generality**: After completing all functions for one conversation, click on **another conversation** and re-run all functions to ensure they are not hard-coded.

---

## ðŸ’¡ Best Practices

### **1. Selector Strategy (Most Important)**

To create robust extractors, use the most stable selectors available. Follow this priority order:

1.  **Unique Data Attributes**: Prefer attributes made for testing, like `data-testid`, `data-cy`, or other unique `data-*` attributes.
2.  **ARIA Attributes**: Use accessibility attributes like `role`, `aria-label`, and `aria-describedby`. These are less likely to change than stylistic classes.
3.  **Stable IDs and Class Names**: Use an element's `id` if it is unique and descriptive. Use class names that represent the component's function (e.g., `.chat-message`), not its style (e.g., `.mt-2`, `.text-blue-500`).
4.  **Element Type + Attributes**: Combine an element type with its attributes (e.g., `button[aria-label="Send"]`, `textarea[name="prompt"]`).
5.  **Structural Relationships**: As a last resort, use parent-child or sibling relationships (e.g., `div > .user-message-avatar + .content`).
6.  **Avoid Text Content**: **Do not use visible text content to select elements**, as it will fail if the language changes.

### **2. Debugging Selectors**

-   If a selector fails, get the `outerHTML` of the closest stable parent element or the entire `document.body` to see the *exact* current DOM structure.
-   Use `browser_take_screenshot` to visually confirm the page state.
-   Check for errors in the browser console that might indicate the page or content failed to load.

### **3. Handling Dynamic Content**

-   Use `browser_wait_for` to wait for an element or text to appear if the content loads dynamically.
-   Use `browser_network_requests` to check if necessary data has finished loading.

---

## ðŸ“‹ Extractor Functions Schema (Your Goal)

You need to write a set of JavaScript extractor functions for the {ASSISTANT} website. Below is the TypeScript type definition (for reference only), your actual output should be **JavaScript functions**.

### TypeScript Type Definitions (Reference)

```typescript
// Data structures
type ChatListItem = {
  id: string;
  title: string;
  updatedAt: string | null;
  isSelected: boolean;
};

type ChatMessage = {
  role: 'user' | 'assistant' | 'tool' | 'system';
  text: string;
  timestamp: string | null;
};

type Chat = {
  title: string;
  messages: ChatMessage[];
};

// Extractor function signatures
type ExtractorFunctions = {
  // Extract structured data
  extractChatList: () => ChatListItem[];
  extractChat: () => Chat | null;

  // Interactive elements (return HTMLElement for manipulation)
  getPromptInput: () => HTMLElement | null;
  getSendButton: () => HTMLElement | null;
  getStopButton: () => HTMLElement | null;

  // State detection
  isLoggedIn: () => boolean;
  isStreaming: () => boolean;
  getErrorMessage: () => string | null;
};
```

### JavaScript Function Format (Your Actual Output)

Each function you write should be **JavaScript executable via `mcp__playwright__browser_evaluate`**. For example:

```javascript
// âœ… Correct example: Return structured data
function extractChatList() {
  return Array.from(document.querySelectorAll('[data-chat-id]')).map(item => ({
    id: item.getAttribute('data-chat-id'),
    title: item.querySelector('.chat-title')?.textContent?.trim() || '',
    updatedAt: item.querySelector('.updated-at')?.textContent?.trim() || null,
    isSelected: item.classList.contains('selected')
  }));
}

// Test with mcp__playwright__browser_evaluate
// Should return: [{ id: '123', title: 'Chat 1', updatedAt: '2025-01-10', isSelected: false }, ...]
```

```javascript
// âœ… Correct example: Return boolean state
function isLoggedIn() {
  return document.querySelector('[data-user-avatar]') !== null;
}

// Test with mcp__playwright__browser_evaluate
// Should return: true or false
```

---

## ðŸš€ Execution Steps

1.  **Open Target Page**:
    -   Use Playwright MCP to navigate to the `{ASSISTANT}` target website at `{URL}`.

2.  **Initial Analysis & State Assessment**:
    -   If not logged in, handle the login process first.
    -   Navigate to a typical conversation page.
    -   Use `browser_evaluate` to get the `document.documentElement.outerHTML`.
    -   Analyze the HTML to create a mental plan for the selectors you will use for all functions.

3.  **Iteratively Write and Test Functions** (in logical groups):

    **Step 3.1: State Detection**
    -   Write and verify `isLoggedIn()`.
    -   Write and verify `isStreaming()` and `getStopButton()` together, as they are related.
    -   Write and verify `getErrorMessage()`.

    **Step 3.2: Chat List & Navigation**
    -   Write and verify `extractChatList()`.

    **Step 3.3: Conversation Content**
    -   Write and verify `extractChat()`. Pay close attention to structural differences between user and assistant messages (e.g., avatars, alignment classes, metadata containers).
    -   Ensure the function correctly handles formatted content like code blocks and lists.

    **Step 3.4: Interactive Elements**
    -   Write and verify `getPromptInput()` and `getSendButton()` together.

4.  **Final Verification**:
    -   Use browser tools to click on a **different conversation**.
    -   Re-run `extractChatList()` and `extractChat()` to ensure they work universally.

5.  **Output Result**:
    -   Organize all verified JavaScript functions into a complete, self-contained script.
    -   Add a comment at the top of the file specifying the target website and the date of creation.
    -   Ensure the file includes the `module.exports` block for Node.js compatibility.
    -   Save the final script to `src/extractors/{ASSISTANT}-extractor.js`.
