üéØ Mission: Build & Test an Assistant Page Extractor (TDD-first, Playwright + MCP)

You are an AI developer working test-driven. You will create a DOM extractor for an AI assistant website (e.g., ChatGPT/Claude/Gemini/Perplexity or a custom site). You must iterate in the live browser via Playwright MCP, write failing tests first, and ship a single JS/TS module that exports the extractor API. Unimplemented parts should be shipped as placeholders that pass compilation and are exercised by pending/skipped tests.

Constraints & Goals
	‚Ä¢	One task per iteration: focus on a single capability at a time:
	1.	login state, 2) generation/streaming state, 3) chat list, 4) chat details, 5) current streaming message.
	‚Ä¢	Deliverable: one file assistant-extractor.ts (TypeScript preferred) exporting the extractor API. If you split for your own convenience during dev, squash into one file before final output.
	‚Ä¢	TDD: write tests first (Playwright Test). Run them via MCP-controlled browser. Iterate until green.
	‚Ä¢	Selectors configurable: support multiple sites via a SelectorsMap + SiteCapabilities.
	‚Ä¢	No frameworks on the page: run only with standard DOM APIs through Playwright.
	‚Ä¢	Graceful placeholders: return typed ErrResult for unsupported/unimplemented operations, with clear error codes.

‚∏ª

Tools You Can Use
	‚Ä¢	Playwright MCP: open/attach to Chromium, navigate, evaluate in page, query elements, click/type, wait conditions.
	‚Ä¢	Typical actions:
	‚Ä¢	browser.open({ url })
	‚Ä¢	page.waitForSelector(css)
	‚Ä¢	page.evaluate(fn, args)
	‚Ä¢	page.click(css) / page.type(css, text)
	‚Ä¢	page.waitForFunction(fn)
	‚Ä¢	Playwright Test (@playwright/test) for assertions and test runner.
	‚Ä¢	TypeScript compilation.
	‚Ä¢	Optional: Snapshots for data structures (chat list, chat details).

‚∏ª

File Layout (during development)
	‚Ä¢	assistant-extractor.ts ‚Üê final single-file export (types + implementation + factory)
	‚Ä¢	tests/ (dev-only; not part of final deliverable)
	‚Ä¢	login.spec.ts
	‚Ä¢	chat-list.spec.ts
	‚Ä¢	chat-details.spec.ts
	‚Ä¢	streaming-state.spec.ts

At the end, output only the single assistant-extractor.ts file in your final response.

‚∏ª

Type & Interface Contracts (include exactly‚Äîfeel free to extend, but don‚Äôt break)

Copy this block into assistant-extractor.ts:

/* ===== Public Types & Interfaces (do not break) ===== */

export type AssistantSite = "chatgpt" | "claude" | "gemini" | "perplexity" | "custom";
export type ChatRole = "user" | "assistant" | "tool" | "system";
export type TurnPhase = "idle" | "thinking" | "generating" | "stopped" | "error";
export type LoginStateStatus = "unknown" | "required" | "logged_in";

export interface GenerationState {
  phase: TurnPhase;
  currentTurnId?: string;
  progress?: number;
  errorMessage?: string;
}

export interface LoginState {
  status: LoginStateStatus;
  user?: { id?: string; name?: string; avatarUrl?: string };
}

export interface SelectorsMap {
  chatListItem?: string;
  chatListItemSelected?: string;
  chatListItemTitle?: string;
  chatListItemUpdatedAt?: string;

  chatTitle?: string;
  chatMessageContainer?: string;
  chatMessageRoleUser?: string;
  chatMessageRoleAssistant?: string;
  chatMessageRoleTool?: string;
  chatMessageRoleSystem?: string;
  chatMessageText?: string;
  chatMessageTimestamp?: string;

  promptInput?: string;
  sendButton?: string;
  stopButton?: string;

  loginIndicator?: string;
  streamingIndicator?: string;
  errorIndicator?: string;
}

export interface SiteCapabilities {
  hasChatList: boolean;
  supportsStreaming: boolean;
  supportsMultiTab: boolean;
  listPagination?: boolean;
}

export interface ElementInfo {
  selector: string;
  strategy?: "css" | "xpath" | "role" | "testId";
  description?: string;
}

export interface PromptInputInfo extends ElementInfo {
  textareaLike: boolean;
  supportsMultiline: boolean;
  placeholder?: string;
  maxLength?: number | null;
}

export interface ChatSummary {
  id: string;
  title: string;
  preview?: string;
  updatedAt?: number;
  archived?: boolean;
}

export interface ChatMessage {
  id: string;
  role: ChatRole;
  text?: string;
  parts?: Array<
    | { type: "text"; text: string }
    | { type: "code"; language?: string; code: string }
    | { type: "image"; alt?: string; src: string }
  >;
  timestamp?: number;
  rawAttrs?: Record<string, string | number | boolean | null | undefined>;
}

export interface ChatDetails {
  id: string;
  title?: string;
  messages: ReadonlyArray<ChatMessage>;
  meta?: Record<string, unknown>;
}

export interface ExtractorError {
  code:
    | "ELEMENT_NOT_FOUND"
    | "TIMEOUT"
    | "UNSUPPORTED"
    | "PARSE_FAILED"
    | "NOT_LOGGED_IN"
    | "UNKNOWN";
  message: string;
  selector?: string;
  cause?: unknown;
}

export interface Result<T> { ok: true; value: T; warn?: string[] }
export interface ErrResult { ok: false; error: ExtractorError; warn?: string[] }
export type Res<T> = Result<T> | ErrResult;
export const isOk = <T,>(r: Res<T>): r is Result<T> => (r as Result<T>).ok === true;
export const isErr = <T,>(r: Res<T>): r is ErrResult => (r as ErrResult).ok === false;

/* ===== Driver Abstraction ===== */
export interface DomDriver {
  exists(el: ElementInfo, timeoutMs?: number): Promise<boolean>;
  getAllTexts(el: ElementInfo, timeoutMs?: number): Promise<string[]>;
  getText(el: ElementInfo, timeoutMs?: number): Promise<string>;
  getAttr(el: ElementInfo, name: string, timeoutMs?: number): Promise<string | null>;
  click(el: ElementInfo, timeoutMs?: number): Promise<void>;
  type(el: ElementInfo, text: string, opts?: { delayMs?: number }): Promise<void>;
  waitForVisible(el: ElementInfo, timeoutMs?: number): Promise<void>;
  eval<T>(fn: () => T | Promise<T>, timeoutMs?: number): Promise<T>;
}

/* ===== Extractor Contracts ===== */
export interface InPageExtractor {
  detectLoginState(): LoginState;
  detectGenerationState(): GenerationState;

  extractChatList(): ReadonlyArray<ChatSummary>;
  extractChatDetails(): ChatDetails;
  extractCurrentStreamingMessage(): ChatMessage | null;

  locatePromptInput(): PromptInputInfo;
  locateStopButton(): ElementInfo | null;
  locateChatInList(chatId: string): ElementInfo | null;
}

export interface AsyncExtractor {
  readonly site: AssistantSite;
  readonly selectors: Readonly<SelectorsMap>;
  readonly capabilities: Readonly<SiteCapabilities>;

  detectLoginState(): Promise<Res<LoginState>>;
  detectGenerationState(): Promise<Res<GenerationState>>;

  extractChatList(): Promise<Res<ReadonlyArray<ChatSummary>>>;
  extractChatDetails(): Promise<Res<ChatDetails>>;
  extractCurrentStreamingMessage(): Promise<Res<ChatMessage | null>>;

  locatePromptInput(): Promise<Res<PromptInputInfo>>;
  locateStopButton(): Promise<Res<ElementInfo | null>>;
  locateChatInList(chatId: string): Promise<Res<ElementInfo | null>>;
}

export interface ExtractorFactory {
  create(driver: DomDriver, site: AssistantSite): AsyncExtractor;
}


‚∏ª

Implementation Skeleton (keep minimal, TDD will drive details)

Append this minimal factory and default implementation to the same file. Return placeholder errors for unimplemented parts so tests can mark them as test.fixme / test.skip until implemented.

/* ===== Helper constructors ===== */
const ok = <T,>(value: T, warn?: string[]): Result<T> => ({ ok: true, value, warn });
const err = (error: ExtractorError, warn?: string[]): ErrResult => ({ ok: false, error, warn });

/* ===== Default Selectors (example draft; override per site in tests) ===== */
export const DEFAULT_SELECTORS: SelectorsMap = {
  chatListItem: "[data-testid='chat-item']",
  chatListItemTitle: "[data-testid='chat-item-title']",
  chatTitle: "[data-testid='chat-title']",
  chatMessageContainer: "[data-testid='message']",
  chatMessageRoleUser: "[data-role='user']",
  chatMessageRoleAssistant: "[data-role='assistant']",
  chatMessageText: "[data-testid='message-text']",
  promptInput: "textarea, [contenteditable='true']",
  stopButton: "[data-testid='stop']",
  loginIndicator: "[data-testid='user-avatar'], [data-user]",
  streamingIndicator: "[data-streaming='true']",
  errorIndicator: "[data-error], .error, [role='alert']",
};

export const DEFAULT_CAPABILITIES: SiteCapabilities = {
  hasChatList: true,
  supportsStreaming: true,
  supportsMultiTab: true,
  listPagination: false,
};

/* ===== In-Page Extractor (evaluated in DOM context) ===== */
export class DefaultInPageExtractor implements InPageExtractor {
  constructor(private selectors: Readonly<SelectorsMap>) {}

  detectLoginState(): LoginState {
    const has = !!document.querySelector(this.selectors.loginIndicator ?? "");
    return { status: has ? "logged_in" : "required" };
  }

  detectGenerationState(): GenerationState {
    const streaming = this.selectors.streamingIndicator
      ? !!document.querySelector(this.selectors.streamingIndicator)
      : false;
    return { phase: streaming ? "generating" : "idle" };
  }

  extractChatList(): ReadonlyArray<ChatSummary> {
    const itemSel = this.selectors.chatListItem;
    if (!itemSel) return [];
    const items = Array.from(document.querySelectorAll<HTMLElement>(itemSel));
    return items.map((el, idx) => {
      const titleEl = this.selectors.chatListItemTitle
        ? el.querySelector<HTMLElement>(this.selectors.chatListItemTitle)
        : null;
      return {
        id: el.getAttribute("data-id") ?? String(idx),
        title: titleEl?.innerText?.trim() || el.innerText?.slice(0, 80) || `Chat ${idx + 1}`,
        preview: undefined,
        updatedAt: undefined,
      };
    });
  }

  extractChatDetails(): ChatDetails {
    const title = this.selectors.chatTitle
      ? document.querySelector<HTMLElement>(this.selectors.chatTitle)?.innerText?.trim()
      : undefined;
    const msgSel = this.selectors.chatMessageContainer ?? "";
    const nodes = Array.from(document.querySelectorAll<HTMLElement>(msgSel));
    const messages = nodes.map<ChatMessage>((el, i) => {
      const role =
        el.closest(this.selectors.chatMessageRoleUser ?? "___nope___") ? "user" :
        el.closest(this.selectors.chatMessageRoleAssistant ?? "___nope___") ? "assistant" :
        el.closest(this.selectors.chatMessageRoleTool ?? "___nope___") ? "tool" :
        el.closest(this.selectors.chatMessageRoleSystem ?? "___nope___") ? "system" : "assistant";
      const text = this.selectors.chatMessageText
        ? el.querySelector<HTMLElement>(this.selectors.chatMessageText)?.innerText ?? ""
        : el.innerText ?? "";
      return { id: el.getAttribute("data-id") ?? String(i), role, text };
    });
    const id = document.location.pathname || "current";
    return { id, title, messages };
  }

  extractCurrentStreamingMessage(): ChatMessage | null {
    if (!this.selectors.streamingIndicator) return null;
    const streamingEl = document.querySelector<HTMLElement>(this.selectors.streamingIndicator);
    if (!streamingEl) return null;
    const text = streamingEl.innerText ?? "";
    return { id: "streaming", role: "assistant", text };
  }

  locatePromptInput(): PromptInputInfo {
    const selector = this.selectors.promptInput ?? "textarea";
    return { selector, textareaLike: true, supportsMultiline: true, description: "Prompt input" };
    // Could be enhanced to inspect contenteditable vs textarea, placeholder, maxlength, etc.
  }

  locateStopButton(): ElementInfo | null {
    if (!this.selectors.stopButton) return null;
    return { selector: this.selectors.stopButton, description: "Stop/Cancel generation" };
  }

  locateChatInList(chatId: string): ElementInfo | null {
    const itemSel = this.selectors.chatListItem;
    if (!itemSel) return null;
    const node = Array.from(document.querySelectorAll<HTMLElement>(itemSel))
      .find(el => el.getAttribute("data-id") === chatId);
    if (!node) return null;
    return { selector: `${itemSel}[data-id="${CSS.escape(chatId)}"]`, description: "Chat list item" };
  }
}

/* ===== Async Extractor using DomDriver ===== */
export class DefaultAsyncExtractor implements AsyncExtractor {
  readonly site: AssistantSite;
  readonly selectors: Readonly<SelectorsMap>;
  readonly capabilities: Readonly<SiteCapabilities>;

  constructor(
    private driver: DomDriver,
    site: AssistantSite,
    selectors: Readonly<SelectorsMap> = DEFAULT_SELECTORS,
    caps: Readonly<SiteCapabilities> = DEFAULT_CAPABILITIES
  ) {
    this.site = site;
    this.selectors = selectors;
    this.capabilities = caps;
  }

  private async inPage<T>(fn: () => T | Promise<T>): Promise<T> {
    return this.driver.eval(fn);
  }

  async detectLoginState(): Promise<Res<LoginState>> {
    try {
      const state = await this.inPage(() => new DefaultInPageExtractor(DEFAULT_SELECTORS).detectLoginState());
      return ok(state);
    } catch (cause) {
      return err({ code: "UNKNOWN", message: "detectLoginState failed", cause });
    }
  }

  async detectGenerationState(): Promise<Res<GenerationState>> {
    try {
      const state = await this.inPage(() => new DefaultInPageExtractor(DEFAULT_SELECTORS).detectGenerationState());
      return ok(state);
    } catch (cause) {
      return err({ code: "UNKNOWN", message: "detectGenerationState failed", cause });
    }
  }

  async extractChatList(): Promise<Res<ReadonlyArray<ChatSummary>>> {
    if (!this.capabilities.hasChatList) {
      return err({ code: "UNSUPPORTED", message: "Site has no chat list" });
    }
    try {
      const list = await this.inPage(() => new DefaultInPageExtractor(DEFAULT_SELECTORS).extractChatList());
      if (!list.length) {
        return err({ code: "ELEMENT_NOT_FOUND", message: "No chat items found", selector: this.selectors.chatListItem });
      }
      return ok(list);
    } catch (cause) {
      return err({ code: "PARSE_FAILED", message: "extractChatList failed", cause });
    }
  }

  async extractChatDetails(): Promise<Res<ChatDetails>> {
    try {
      const details = await this.inPage(() => new DefaultInPageExtractor(DEFAULT_SELECTORS).extractChatDetails());
      return ok(details);
    } catch (cause) {
      return err({ code: "PARSE_FAILED", message: "extractChatDetails failed", cause });
    }
  }

  async extractCurrentStreamingMessage(): Promise<Res<ChatMessage | null>> {
    if (!this.capabilities.supportsStreaming) return ok(null);
    try {
      const msg = await this.inPage(() => new DefaultInPageExtractor(DEFAULT_SELECTORS).extractCurrentStreamingMessage());
      return ok(msg);
    } catch (cause) {
      return err({ code: "UNKNOWN", message: "extractCurrentStreamingMessage failed", cause });
    }
  }

  async locatePromptInput(): Promise<Res<PromptInputInfo>> {
    try {
      const info = await this.inPage(() => new DefaultInPageExtractor(DEFAULT_SELECTORS).locatePromptInput());
      const visible = await this.driver.exists({ selector: info.selector });
      if (!visible) return err({ code: "ELEMENT_NOT_FOUND", message: "Prompt input not visible", selector: info.selector });
      return ok(info);
    } catch (cause) {
      return err({ code: "UNKNOWN", message: "locatePromptInput failed", cause });
    }
  }

  async locateStopButton(): Promise<Res<ElementInfo | null>> {
    try {
      const el = await this.inPage(() => new DefaultInPageExtractor(DEFAULT_SELECTORS).locateStopButton());
      if (!el) return ok(null);
      const visible = await this.driver.exists(el);
      return visible ? ok(el) : ok(null);
    } catch (cause) {
      return err({ code: "UNKNOWN", message: "locateStopButton failed", cause });
    }
  }

  async locateChatInList(chatId: string): Promise<Res<ElementInfo | null>> {
    try {
      const el = await this.inPage(() => new DefaultInPageExtractor(DEFAULT_SELECTORS).locateChatInList(chatId));
      if (!el) return ok(null);
      const visible = await this.driver.exists(el);
      return visible ? ok(el) : ok(null);
    } catch (cause) {
      return err({ code: "UNKNOWN", message: "locateChatInList failed", cause });
    }
  }
}

/* ===== Factory ===== */
export const extractorFactory: ExtractorFactory = {
  create(driver: DomDriver, site: AssistantSite): AsyncExtractor {
    // In real usage, choose selectors per site
    return new DefaultAsyncExtractor(driver, site, DEFAULT_SELECTORS, DEFAULT_CAPABILITIES);
  },
};

Notes
	‚Ä¢	The in-page extractor is intentionally simple and safe to run via page.evaluate.
	‚Ä¢	Adjust DEFAULT_SELECTORS per target site in tests; do not hardcode site-specific selectors in the implementation.

‚∏ª

Example Test Specs (write these first)

Login State (wait for manual login if required):

import { test, expect } from "@playwright/test";
import { extractorFactory, isOk } from "../assistant-extractor";
import { makePlaywrightDriver } from "./playwright-driver"; // small adapter you write

test.describe("Login state", () => {
  test("detects logged_in after user logs in", async ({ page }) => {
    const driver = makePlaywrightDriver(page);
    await page.goto(process.env.TARGET_URL!);

    // If not logged in, pause and instruct the human/dev to log in:
    // (Or poll until avatar appears)
    await page.waitForLoadState("domcontentloaded");
    // optional: test.step("Manual login", async () => { await page.pause(); });

    const extractor = extractorFactory.create(driver, "custom");
    const res = await extractor.detectLoginState();
    expect(isOk(res)).toBeTruthy();
    expect(res.ok && res.value.status).toBe("logged_in");
  });
});

Chat List:

test.describe("Chat list", () => {
  test("extracts non-empty chat list", async ({ page }) => {
    const driver = makePlaywrightDriver(page);
    await page.goto(process.env.TARGET_URL!);

    const extractor = extractorFactory.create(driver, "custom");
    const listRes = await extractor.extractChatList();
    if (!listRes.ok) test.fail(true, listRes.error.message);
    expect(listRes.value.length).toBeGreaterThan(0);
    for (const item of listRes.value) {
      expect(item.id).toBeTruthy();
      expect(item.title).toBeTruthy();
    }
  });
});

Chat Details:

test.describe("Chat details", () => {
  test("extracts messages for the current chat", async ({ page }) => {
    const driver = makePlaywrightDriver(page);
    await page.goto(process.env.TARGET_URL!);

    const extractor = extractorFactory.create(driver, "custom");
    const details = await extractor.extractChatDetails();
    if (!details.ok) test.fail(true, details.error.message);
    expect(details.value.messages.length).toBeGreaterThan(0);
  });
});

Streaming State:

test.describe("Streaming", () => {
  test.skip(true, "Implement when streaming selectors are known");
  // Later: type a prompt, click send, assert generating -> idle transitions.
});


‚∏ª

Minimal Playwright Driver Adapter (dev helper)

Create a tiny adapter so the extractor talks to Playwright via the DomDriver interface.

// tests/playwright-driver.ts
import { DomDriver, ElementInfo } from "../assistant-extractor";
import { Page } from "@playwright/test";

export function makePlaywrightDriver(page: Page): DomDriver {
  const toSelector = (el: ElementInfo) => el.selector; // strategy extensible later

  return {
    async exists(el, timeoutMs) {
      try {
        await page.waitForSelector(toSelector(el), { timeout: timeoutMs ?? 2000, state: "visible" });
        return true;
      } catch { return false; }
    },
    async getAllTexts(el, timeoutMs) {
      await page.waitForSelector(toSelector(el), { timeout: timeoutMs ?? 2000 });
      return page.$$eval(toSelector(el), els => els.map(e => (e as HTMLElement).innerText ?? ""));
    },
    async getText(el, timeoutMs) {
      await page.waitForSelector(toSelector(el), { timeout: timeoutMs ?? 2000 });
      return page.$eval(toSelector(el), e => (e as HTMLElement).innerText ?? "");
    },
    async getAttr(el, name, timeoutMs) {
      await page.waitForSelector(toSelector(el), { timeout: timeoutMs ?? 2000 });
      return page.$eval(toSelector(el), (e, n) => e.getAttribute(n as string), name);
    },
    async click(el, timeoutMs) {
      await page.click(toSelector(el), { timeout: timeoutMs ?? 5000 });
    },
    async type(el, text, opts) {
      await page.type(toSelector(el), text, { delay: opts?.delayMs ?? 0 });
    },
    async waitForVisible(el, timeoutMs) {
      await page.waitForSelector(toSelector(el), { timeout: timeoutMs ?? 5000, state: "visible" });
    },
    async eval(fn, _timeoutMs) {
      return page.evaluate(fn);
    },
  };
}


‚∏ª

TDD Workflow (repeat per capability)
	1.	Pick one capability (e.g., chat_list).
	2.	Write a failing test that expresses the behavior (selectors may be rough first).
	3.	Run via Playwright MCP:
	‚Ä¢	Launch the browser to the target AI site: page.goto(TARGET_URL).
	‚Ä¢	If login is needed:
	‚Ä¢	Try detect ‚Üí if required, pause and wait for the human to log in (or implement a polling wait until avatar/loginIndicator appears).
	4.	Implement the smallest code in assistant-extractor.ts to make the test pass.
	5.	Refactor (improve selectors mapping, factor helpers) while keeping tests green.
	6.	Commit.
	7.	Move to the next capability.

‚∏ª

Site Selector Profiles (examples to override in tests)

export const SELECTORS_CHATGPT: SelectorsMap = {
  chatListItem: "nav [data-testid='conversation-list'] a[href*='/c/']",
  chatListItemTitle: "span",
  chatTitle: "main h1, main [data-testid='conversation-title']",
  chatMessageContainer: "main [data-message-id]",
  chatMessageRoleUser: "[data-message-author-role='user']",
  chatMessageRoleAssistant: "[data-message-author-role='assistant']",
  chatMessageText: "[data-message-text], .markdown",
  promptInput: "form textarea",
  stopButton: "button[aria-label='Stop generating']",
  loginIndicator: "img[alt*='avatar'], [data-testid='user-menu']",
  streamingIndicator: "[aria-live='polite'] .result-streaming",
  errorIndicator: "[role='alert'], .toast-error",
};

export const SELECTORS_CLAUDE: SelectorsMap = {
  // (fill with real selectors during tests)
};


‚∏ª

Acceptance Criteria
	‚Ä¢	‚úÖ Final output is one file assistant-extractor.ts exporting:
	‚Ä¢	All public types and interfaces above (unchanged).
	‚Ä¢	DefaultInPageExtractor, DefaultAsyncExtractor, extractorFactory.
	‚Ä¢	DEFAULT_SELECTORS, DEFAULT_CAPABILITIES.
	‚Ä¢	‚úÖ Tests exist (during development) for: login state, chat list, chat details. Streaming may start as skipped and become active later.
	‚Ä¢	‚úÖ Works interactively via Playwright MCP against the chosen site:
	‚Ä¢	Can wait for manual login and then detect logged_in.
	‚Ä¢	Can extract a non-empty chat list on sites that have one.
	‚Ä¢	Can extract chat details with a list of messages and roles when a chat is open.
	‚Ä¢	‚úÖ Unimplemented/unsupported parts return typed ErrResult with helpful code and message.
	‚Ä¢	‚úÖ No site-specific logic hardcoded into implementation‚Äîselectors are injectable.

‚∏ª

Runbook (dev)
	‚Ä¢	Set TARGET_URL env var to the AI assistant site home/chat page.
	‚Ä¢	Start tests via MCP‚Äôs Playwright runner (or local CLI):
	‚Ä¢	npx playwright test tests/login.spec.ts
	‚Ä¢	npx playwright test tests/chat-list.spec.ts
	‚Ä¢	When tests prompt for login, switch to the MCP-controlled browser and sign in.
	‚Ä¢	Iterate until all green. Then consolidate into the single file deliverable.

‚∏ª

What to Output Now
	‚Ä¢	Generate the single assistant-extractor.ts file containing:
	1.	The type/interface contract block (unaltered),
	2.	The implementation skeleton above (can extend),
	3.	DEFAULT_SELECTORS and DEFAULT_CAPABILITIES,
	4.	extractorFactory for easy construction.

For anything you cannot finalize yet (e.g., streaming nuances), leave a typed placeholder that returns ErrResult or minimal ok(null) as shown, so it compiles and tests can be skipped or TODO‚Äôd without breaking.
