---
chatSessionId: e16a5771-65cf-4907-869a-4aa4ef801e18
---

我需要請 AI 針對 ai assistant 網頁寫 extractor，用 test-driven 開發

我想的作法（不完整）：
- 使用 playwright mcp 做開發、測試，瀏覽網站、開發、並直接在頁面上測試，迭代
- extractor 要用 js class or functions? 需要方便透過 playwright 直接測試
- 每次任務只針對一個功能去做開發/測試，例如 1. logged in 2. chat list 3. chat
- 輸出成果為一個 js file，還沒開發的設為 placeholder

- 用 playwright mcp 操作瀏覽器，開啟指定的 ai assistant 網站
- 如果需要 loggedin ，先等候使用者 loggedin
- 然後直接使用 playwright，在當前的瀏覽器上測試 extract functions，看結果並修改，改進迭代 extract functions
- 嘗試抓取 chat list
- 針對不同的 chat ，開啟多個分頁分別載入，透過瀏覽、比較多個 chats page，來抓取 chat

請先設計 interface, types
以下是一個參考

```typescript
interface AssistantPageExtractor {
  // === State Detection ===
  detectLoginState(): LoginState;
  detectGenerationState(): GenerationState;
  
  // === Data Extraction ===
  extractChatList(): readonly ChatSummary[];
  extractChatDetails(): ChatDetails;
  extractCurrentStreamingMessage(): ChatMessage | null;
  
  // === Element Location ===
  locatePromptInput(): PromptInputInfo;
  locateStopButton(): ElementInfo | null;
  locateChatInList(chatId: string): ElementInfo | null;
}
```





<!-- new_session -->

## Objective
Develop **pure DOM extraction functions** for AI assistant web interfaces (Claude, ChatGPT, Gemini, Grok). These are read-only JavaScript functions that extract data from the page without performing any actions.

**Your responsibility:** Write pure JavaScript functions that **only read** the DOM and return data.

**Current Target**: Gemini https://gemini.google.com/app

## Target Functions
```typescript
interface AssistantPageExtractor {
  // === State Detection ===
  detectLoginState(): LoginState;
  detectGenerationState(): GenerationState;
  
  // === Data Extraction ===
  extractChatList(): readonly ChatSummary[];
  extractChatDetails(): ChatDetails;
  extractCurrentStreamingMessage(): ChatMessage | null;
  
  // === Element Location (return info, don't interact) ===
  locatePromptInput(): PromptInputInfo;
  locateStopButton(): ElementInfo | null;
  locateChatInList(chatId: string): ElementInfo | null;
}
```

### Return Types
```typescript
interface LoginState {
  assistantId: 'claude' | 'chatgpt' | 'gemini' | 'grok';
  authenticated: boolean;
  defaultModelId?: string;
  availableModelIds?: string[];
  message?: string;
}

interface GenerationState {
  isGenerating: boolean;
  canStop: boolean;
  currentMessageId?: string;
}

interface PromptInputInfo {
  available: boolean;
  selector: string;
  isDisabled: boolean;
  placeholder?: string;
  submitButtonSelector?: string;
}

interface ElementInfo {
  exists: boolean;
  selector: string;
  isVisible?: boolean;
  isEnabled?: boolean;
}

interface ChatSummary {
  id: string;
  title: string;
  url: string;
  updatedAt: string;
  modelId?: string;
}

interface ChatMessage {
  id: string;
  role: 'user' | 'assistant' | 'system' | 'tool';
  createdAt: string;
  contentMarkdown: string;
  contentHtml?: string;
}

interface ChatDetails {
  id: string;
  title: string;
  url: string;
  modelId?: string;
  updatedAt: string;
  messages: readonly ChatMessage[];
}
```

## Development Workflow

### Phase 1: Exploration
Navigate to the target assistant using Playwright MCP and explore:
- Login state indicators (user menu, login buttons, avatars)
- Chat list structure (selectors, data attributes, URLs)
- Message elements (roles, content, timestamps)
- Generation indicators (stop buttons, streaming states, loading spinners)
- Prompt input elements (textarea, submit button)

Use `page.evaluate()` to inspect the DOM and log findings.

### Phase 2: Develop Functions
Implement each function individually. Test using `page.evaluate()`:
- Inject the complete function
- Execute and check the result
- Refine based on findings
- Repeat until correct

### Phase 3: Refinement
Test against different scenarios:
- Empty states (no chats, logged out)
- Loading states (partial content)
- Different content types (code, images, files)
- Long chats (100+ messages)
- Error conditions (missing elements)

Add fallback selectors and handle edge cases.

### Phase 4: Create Artifact
Combine all working functions into a single JavaScript file with:
- JSDoc comments for each function
- Error handling
- Exports for different environments (module.exports, window)

## Guidelines

### Keep It Simple
- **Don't over-engineer**: Use straightforward DOM queries
- **Avoid complexity**: No unnecessary abstractions or helper classes
- **Start minimal**: Get it working first, optimize only if needed
- **Clear code**: Readable is better than clever

### Pure Functions Only
- ❌ Don't: Click, type, navigate, modify DOM
- ✅ Do: Read DOM, return data structures

### Robust Selectors
- Prefer: `[data-testid="..."]` or `[data-*]` attributes
- Fallback: Multiple selector options
- Avoid: Generated class names, fragile selectors

### Defensive Programming
- Use optional chaining: `element?.querySelector('.title')?.textContent`
- Provide defaults: `title || 'Untitled'`
- Validate data: Check for null/undefined before using
- Wrap in try-catch: Return safe defaults on errors

### Return Complete Data
Always return all expected fields, use `undefined` for missing optional fields.

## Testing Checklist

- [ ] Works when logged out
- [ ] Works with empty chat list
- [ ] Works with typical content (10-20 items)
- [ ] Works with large content (100+ items)
- [ ] Returns correct data types
- [ ] Handles missing elements gracefully
- [ ] Has error handling
- [ ] Includes JSDoc comments

## Expected Deliverables

For each assistant:
1. **Exploration findings** - Key DOM structure insights
2. **Test results** - Successful execution of each function
3. **Final extractor file** - Complete JavaScript module

## Final File Structure

```javascript
/**
 * [Assistant Name] Page Extractor
 * Pure functions for extracting data from [assistant] web interface
 */

function detectLoginState() { /* ... */ }
function detectGenerationState() { /* ... */ }
function extractChatList() { /* ... */ }
function extractChatDetails() { /* ... */ }
function extractCurrentStreamingMessage() { /* ... */ }
function locatePromptInput() { /* ... */ }
function locateStopButton() { /* ... */ }
function locateChatInList(chatId) { /* ... */ }

// Exports
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { /* all functions */ };
}
if (typeof window !== 'undefined') {
  window.[Assistant]Extractor = { /* all functions */ };
}
```

## How to Start

When asked to develop an extractor:
1. Navigate to the target assistant website
2. Explore the DOM structure using `page.evaluate()`
3. Implement functions one by one, testing each
4. Refine based on edge cases
5. Create final artifact when all functions work

**Begin with:** "I'll develop the [assistant] page extractor. Let me explore the page structure first..."

---

**Remember:** Keep it simple. Read-only functions. Test iteratively using Playwright MCP.

<!-- new_session -->

目前注意到的問題：
- 限制只能 read dom，有時為了要 extract，需要wait page render、或是 scroll，這些我也覺得是可以加入到 extraction function 裡
- 在抓取 chat messages，應該要先開多個 tabs，分別瀏覽不同的 chats，透過比較多個 chats，才容易找出通用的 pattern
- 寫完後要測試，要再多個不同的 tabs （chats）做測試




